import chisel3.RawModule
import chisel3.stage.ChiselGeneratorAnnotation
import firrtl.analyses.{CircuitGraph, ConnectionGraph, InstanceKeyGraph}
import firrtl.annotations.{CircuitTarget, InstanceTarget, ModuleTarget}
import firrtl.graph.PathNotFoundException
import firrtl.options.{Dependency, TargetDirAnnotation}
import firrtl.passes.ExpandWhensAndCheck
import firrtl.{CircuitState, FileUtils, HighForm, LowForm, Parser, Transform, UnknownForm}

import java.io.PrintWriter

class AnalyzeCircuit(modulename:String,tclfilename:String) extends RawModule{
  def inputForm = HighForm
  def outputForm = HighForm

  val circuit = new firrtl.stage.transforms.Compiler(Seq(Dependency[ExpandWhensAndCheck]))
    .runTransform(
      CircuitState(Parser.parse(FileUtils.getText("Outputs/"+modulename+"/"+modulename+".fir")), UnknownForm)
    )
    .circuit

  val Test = ModuleTarget(modulename, modulename)
  val irGraph = ConnectionGraph(circuit)


  //Find UAC module
  val circuitGraph = CircuitGraph(circuit)
  val C = CircuitTarget(modulename)

  var c = C.module("ACG")
  var recordpath = circuitGraph.absolutePaths(c)
  for(i <- 1 until 2000 ){//2000 is max number of ACGs in design, the vale can be modified according to needs
    c = C.module("ACG_"+i.toString)
    recordpath ++= circuitGraph.absolutePaths(c)
  }
  val pathlength = recordpath.length//record the number of UACs


  //Transform paths to the required format
  val repath = Array.ofDim[String](pathlength, 30)
  for(n <- 0 until pathlength){
    repath(n) = recordpath(n).toString.split("/")
    //repath(n).foreach(println)
  }
  val clickPath = new Array[InstanceTarget](pathlength)
  for(i <- 0 until pathlength){
    for (j <- 2 until repath(i).length) {
      if(j == 2) clickPath(i) = Test.instOf(repath(i)(2).split(":")(0), repath(i)(2).split(":")(1))
      else clickPath(i) = clickPath(i).instOf(repath(i)(j).split(":")(0), repath(i)(j).split(":")(1))
    }
  }

  //Create tcl file to record the fire signal of asynchronous controller
  val outputfile = new PrintWriter(tclfilename+"/"+modulename+"_AC.tcl")

  val OutPath = new Array[String](pathlength)
  for(n <- 0 until pathlength){
    OutPath(n) = repath(n)(1).split(":")(0)
    for(m <- 2 until repath(n).length){
      OutPath(n) = OutPath(n)+"/"+repath(n)(m).split(":")(0)
    }
  }
  var outrun = s""

  outputfile.printf("# Generated by ASYNC-Chisel. \n# For more information please visit https://github.com/Jilin-Zhang/ASYNC-Chisel \n\n")
  for(n <- 0 until pathlength){
    outputfile.printf("Async controller %-3s: %-40s \n", n, OutPath(n))
  }
  outputfile.close()

  //Generate tcl file to find connection relationship between asynchronous controllers
  val outputfile2 = new PrintWriter(tclfilename+"/"+modulename+"_conn.tcl")
  var output = s""

  val indexInNum = new Array[Int](pathlength)
  for(n <- 0 until pathlength){
    for(m <- 0 until 1000 if irGraph.reachableFrom(clickPath(n).ref("In").index(m).field("Req")).isEmpty== false) {
      indexInNum(n) = m+1
    }
  }

  val indexOutNum = new Array[Int](pathlength)
  for(n <- 0 until pathlength){
    for(m <- 0 until 1000 if irGraph.reachableFrom(clickPath(n).ref("Out").index(m).field("Req")).isEmpty== false) {
      indexOutNum(n) = m+1
    }
  }

  var num:Int = 0

  outputfile2.printf("# Generated by ASYNC-Chisel. \n# For more information please visit https://github.com/Jilin-Zhang/ASYNC-Chisel \n\n")
  for(n <- 0 until pathlength) {
    for (m <- 0 until pathlength) {
      for (i <- 0 until indexOutNum(n)) {
        for (j <- 0 until indexInNum(m)) {
          try {
            val paths = irGraph.path(clickPath(n).ref("Out").index(i).field("Req"), clickPath(m).ref("In").index(j).field("Req"))
            val pp = irGraph.reachableFrom(clickPath(n).ref("Req"))
            outputfile2.printf(s"-from\t%-40s -to\t%-40s -through \t${OutPath(m)}/Dreq_${j}/Z \n",OutPath(n),OutPath(m))
            num = num + 1
          } catch { //catch abnormal
            case ex: PathNotFoundException => {}
          }

        }
      }
    }
  }
  outputfile2.close()

}
object AnalyzeCircuit extends App {
  (new chisel3.stage.ChiselStage).execute(args, Seq(ChiselGeneratorAnnotation(() => new AnalyzeCircuit(args(0),args(1)))))
  //(new chisel3.stage.ChiselStage).execute(args, Seq(ChiselGeneratorAnnotation(() => new AnalyzeCircuit("AddOne_3Stage","C://Users/qianc/Desktop/sdc"))))
}
